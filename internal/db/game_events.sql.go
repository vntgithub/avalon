// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: game_events.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGameEvent = `-- name: CreateGameEvent :one
INSERT INTO game_events (game_id, room_player_id, type, payload_json)
VALUES ($1, $2, $3, $4)
RETURNING id, game_id, room_player_id, type, payload_json, created_at
`

type CreateGameEventParams struct {
	GameID       pgtype.UUID `json:"game_id"`
	RoomPlayerID pgtype.UUID `json:"room_player_id"`
	Type         string      `json:"type"`
	PayloadJson  []byte      `json:"payload_json"`
}

func (q *Queries) CreateGameEvent(ctx context.Context, arg CreateGameEventParams) (GameEvent, error) {
	row := q.db.QueryRow(ctx, createGameEvent,
		arg.GameID,
		arg.RoomPlayerID,
		arg.Type,
		arg.PayloadJson,
	)
	var i GameEvent
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.RoomPlayerID,
		&i.Type,
		&i.PayloadJson,
		&i.CreatedAt,
	)
	return i, err
}

const getGameEventsByGameId = `-- name: GetGameEventsByGameId :many
SELECT id, game_id, room_player_id, type, payload_json, created_at
FROM game_events
WHERE game_id = $1
ORDER BY created_at ASC
`

func (q *Queries) GetGameEventsByGameId(ctx context.Context, gameID pgtype.UUID) ([]GameEvent, error) {
	rows, err := q.db.Query(ctx, getGameEventsByGameId, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GameEvent{}
	for rows.Next() {
		var i GameEvent
		if err := rows.Scan(
			&i.ID,
			&i.GameID,
			&i.RoomPlayerID,
			&i.Type,
			&i.PayloadJson,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGameEventsByGameIdAfter = `-- name: GetGameEventsByGameIdAfter :many
SELECT id, game_id, room_player_id, type, payload_json, created_at
FROM game_events
WHERE game_id = $1 AND created_at > $2
ORDER BY created_at ASC
`

type GetGameEventsByGameIdAfterParams struct {
	GameID    pgtype.UUID        `json:"game_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetGameEventsByGameIdAfter(ctx context.Context, arg GetGameEventsByGameIdAfterParams) ([]GameEvent, error) {
	rows, err := q.db.Query(ctx, getGameEventsByGameIdAfter, arg.GameID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GameEvent{}
	for rows.Next() {
		var i GameEvent
		if err := rows.Scan(
			&i.ID,
			&i.GameID,
			&i.RoomPlayerID,
			&i.Type,
			&i.PayloadJson,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomPlayersByGameId = `-- name: GetRoomPlayersByGameId :many
SELECT rp.id, rp.room_id, rp.display_name, rp.is_host, rp.created_at
FROM room_players rp
INNER JOIN game_players gp ON gp.room_player_id = rp.id
WHERE gp.game_id = $1
ORDER BY rp.created_at ASC
`

type GetRoomPlayersByGameIdRow struct {
	ID          pgtype.UUID        `json:"id"`
	RoomID      pgtype.UUID        `json:"room_id"`
	DisplayName string             `json:"display_name"`
	IsHost      bool               `json:"is_host"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetRoomPlayersByGameId(ctx context.Context, gameID pgtype.UUID) ([]GetRoomPlayersByGameIdRow, error) {
	rows, err := q.db.Query(ctx, getRoomPlayersByGameId, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRoomPlayersByGameIdRow{}
	for rows.Next() {
		var i GetRoomPlayersByGameIdRow
		if err := rows.Scan(
			&i.ID,
			&i.RoomID,
			&i.DisplayName,
			&i.IsHost,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
