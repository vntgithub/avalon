// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: games.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGame = `-- name: CreateGame :one
INSERT INTO games (room_id, status, config_json)
VALUES ($1, $2, $3)
RETURNING id, room_id, status, config_json, created_at, ended_at
`

type CreateGameParams struct {
	RoomID     pgtype.UUID `json:"room_id"`
	Status     string      `json:"status"`
	ConfigJson []byte      `json:"config_json"`
}

func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) (Game, error) {
	row := q.db.QueryRow(ctx, createGame, arg.RoomID, arg.Status, arg.ConfigJson)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.RoomID,
		&i.Status,
		&i.ConfigJson,
		&i.CreatedAt,
		&i.EndedAt,
	)
	return i, err
}

const createGamePlayer = `-- name: CreateGamePlayer :one
INSERT INTO game_players (game_id, room_player_id, role)
VALUES ($1, $2, $3)
RETURNING id, game_id, room_player_id, role, joined_at, left_at
`

type CreateGamePlayerParams struct {
	GameID       pgtype.UUID `json:"game_id"`
	RoomPlayerID pgtype.UUID `json:"room_player_id"`
	Role         pgtype.Text `json:"role"`
}

func (q *Queries) CreateGamePlayer(ctx context.Context, arg CreateGamePlayerParams) (GamePlayer, error) {
	row := q.db.QueryRow(ctx, createGamePlayer, arg.GameID, arg.RoomPlayerID, arg.Role)
	var i GamePlayer
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.RoomPlayerID,
		&i.Role,
		&i.JoinedAt,
		&i.LeftAt,
	)
	return i, err
}

const createGameStateSnapshot = `-- name: CreateGameStateSnapshot :one
INSERT INTO game_state_snapshots (game_id, version, state_json)
VALUES ($1, $2, $3)
RETURNING id, game_id, version, state_json, created_at
`

type CreateGameStateSnapshotParams struct {
	GameID    pgtype.UUID `json:"game_id"`
	Version   int32       `json:"version"`
	StateJson []byte      `json:"state_json"`
}

func (q *Queries) CreateGameStateSnapshot(ctx context.Context, arg CreateGameStateSnapshotParams) (GameStateSnapshot, error) {
	row := q.db.QueryRow(ctx, createGameStateSnapshot, arg.GameID, arg.Version, arg.StateJson)
	var i GameStateSnapshot
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.Version,
		&i.StateJson,
		&i.CreatedAt,
	)
	return i, err
}

const getGameById = `-- name: GetGameById :one
SELECT id, room_id, status, config_json, created_at, ended_at
FROM games
WHERE id = $1
`

func (q *Queries) GetGameById(ctx context.Context, id pgtype.UUID) (Game, error) {
	row := q.db.QueryRow(ctx, getGameById, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.RoomID,
		&i.Status,
		&i.ConfigJson,
		&i.CreatedAt,
		&i.EndedAt,
	)
	return i, err
}

const getGamesByRoomId = `-- name: GetGamesByRoomId :many
SELECT id, room_id, status, config_json, created_at, ended_at
FROM games
WHERE room_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetGamesByRoomId(ctx context.Context, roomID pgtype.UUID) ([]Game, error) {
	rows, err := q.db.Query(ctx, getGamesByRoomId, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Game{}
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.RoomID,
			&i.Status,
			&i.ConfigJson,
			&i.CreatedAt,
			&i.EndedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestGameStateSnapshotByGameId = `-- name: GetLatestGameStateSnapshotByGameId :one
SELECT id, game_id, version, state_json, created_at
FROM game_state_snapshots
WHERE game_id = $1
ORDER BY version DESC
LIMIT 1
`

func (q *Queries) GetLatestGameStateSnapshotByGameId(ctx context.Context, gameID pgtype.UUID) (GameStateSnapshot, error) {
	row := q.db.QueryRow(ctx, getLatestGameStateSnapshotByGameId, gameID)
	var i GameStateSnapshot
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.Version,
		&i.StateJson,
		&i.CreatedAt,
	)
	return i, err
}

const getRoomById = `-- name: GetRoomById :one
SELECT id, code, password_hash, settings_json, created_at, updated_at
FROM rooms
WHERE id = $1
`

func (q *Queries) GetRoomById(ctx context.Context, id pgtype.UUID) (Room, error) {
	row := q.db.QueryRow(ctx, getRoomById, id)
	var i Room
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.PasswordHash,
		&i.SettingsJson,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRoomPlayersByRoomId = `-- name: GetRoomPlayersByRoomId :many
SELECT id, room_id, display_name, is_host, user_id, created_at
FROM room_players
WHERE room_id = $1
ORDER BY created_at ASC
`

type GetRoomPlayersByRoomIdRow struct {
	ID          pgtype.UUID        `json:"id"`
	RoomID      pgtype.UUID        `json:"room_id"`
	DisplayName string             `json:"display_name"`
	IsHost      bool               `json:"is_host"`
	UserID      pgtype.UUID        `json:"user_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetRoomPlayersByRoomId(ctx context.Context, roomID pgtype.UUID) ([]GetRoomPlayersByRoomIdRow, error) {
	rows, err := q.db.Query(ctx, getRoomPlayersByRoomId, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRoomPlayersByRoomIdRow{}
	for rows.Next() {
		var i GetRoomPlayersByRoomIdRow
		if err := rows.Scan(
			&i.ID,
			&i.RoomID,
			&i.DisplayName,
			&i.IsHost,
			&i.UserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGameStatus = `-- name: UpdateGameStatus :exec
UPDATE games
SET status = $2, ended_at = $3
WHERE id = $1
`

type UpdateGameStatusParams struct {
	ID      pgtype.UUID        `json:"id"`
	Status  string             `json:"status"`
	EndedAt pgtype.Timestamptz `json:"ended_at"`
}

func (q *Queries) UpdateGameStatus(ctx context.Context, arg UpdateGameStatusParams) error {
	_, err := q.db.Exec(ctx, updateGameStatus, arg.ID, arg.Status, arg.EndedAt)
	return err
}
